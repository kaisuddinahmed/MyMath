import { Internals, } from 'remotion';
import { handleArtifacts } from './artifact';
import { createScaffold } from './create-scaffold';
import { makeInternalState } from './internal-state';
import { onlyOneRenderAtATimeQueue } from './render-operations-queue';
import { sendUsageEvent } from './send-telemetry-event';
import { takeScreenshot } from './take-screenshot';
import { waitForReady } from './wait-for-ready';
async function internalRenderStillOnWeb({ frame, delayRenderTimeoutInMilliseconds, logLevel, inputProps, schema, imageFormat, mediaCacheSizeInBytes, composition, signal, onArtifact, licenseKey, }) {
    var _a, _b, _c, _d, _e, _f;
    const resolved = await Internals.resolveVideoConfig({
        calculateMetadata: (_a = composition.calculateMetadata) !== null && _a !== void 0 ? _a : null,
        signal: signal !== null && signal !== void 0 ? signal : new AbortController().signal,
        defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        compositionId: composition.id,
        compositionDurationInFrames: (_c = composition.durationInFrames) !== null && _c !== void 0 ? _c : null,
        compositionFps: (_d = composition.fps) !== null && _d !== void 0 ? _d : null,
        compositionHeight: (_e = composition.height) !== null && _e !== void 0 ? _e : null,
        compositionWidth: (_f = composition.width) !== null && _f !== void 0 ? _f : null,
    });
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        return Promise.reject(new Error('renderStillOnWeb() was cancelled'));
    }
    const internalState = makeInternalState();
    const { delayRenderScope, div, cleanupScaffold, collectAssets } = await createScaffold({
        width: resolved.width,
        height: resolved.height,
        delayRenderTimeoutInMilliseconds,
        logLevel,
        resolvedProps: resolved.props,
        id: resolved.id,
        mediaCacheSizeInBytes,
        audioEnabled: false,
        Component: composition.component,
        videoEnabled: true,
        durationInFrames: resolved.durationInFrames,
        fps: resolved.fps,
        schema: schema !== null && schema !== void 0 ? schema : null,
        initialFrame: frame,
        defaultCodec: resolved.defaultCodec,
        defaultOutName: resolved.defaultOutName,
    });
    const artifactsHandler = handleArtifacts();
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        await waitForReady({
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
            scope: delayRenderScope,
            signal,
            apiName: 'renderStillOnWeb',
            internalState: null,
        });
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        const imageData = await takeScreenshot({
            div,
            width: resolved.width,
            height: resolved.height,
            imageFormat,
            logLevel,
            internalState,
        });
        const assets = collectAssets.current.collectAssets();
        if (onArtifact) {
            await artifactsHandler.handle({ imageData, frame, assets, onArtifact });
        }
        sendUsageEvent({
            licenseKey: licenseKey !== null && licenseKey !== void 0 ? licenseKey : null,
            succeeded: true,
            apiName: 'renderStillOnWeb',
        });
        return { blob: imageData, internalState };
    }
    catch (err) {
        sendUsageEvent({
            succeeded: false,
            licenseKey: licenseKey !== null && licenseKey !== void 0 ? licenseKey : null,
            apiName: 'renderStillOnWeb',
        }).catch((err2) => {
            Internals.Log.error({ logLevel: 'error', tag: 'web-renderer' }, 'Failed to send usage event', err2);
        });
        throw err;
    }
    finally {
        internalState.cleanup();
        cleanupScaffold();
    }
}
export const renderStillOnWeb = (options) => {
    onlyOneRenderAtATimeQueue.ref = onlyOneRenderAtATimeQueue.ref
        .catch(() => Promise.resolve())
        .then(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return internalRenderStillOnWeb({
            ...options,
            delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
            logLevel: (_c = (_b = options.logLevel) !== null && _b !== void 0 ? _b : window.remotion_logLevel) !== null && _c !== void 0 ? _c : 'info',
            schema: (_d = options.schema) !== null && _d !== void 0 ? _d : undefined,
            mediaCacheSizeInBytes: (_e = options.mediaCacheSizeInBytes) !== null && _e !== void 0 ? _e : null,
            signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null,
            onArtifact: (_g = options.onArtifact) !== null && _g !== void 0 ? _g : null,
            licenseKey: (_h = options.licenseKey) !== null && _h !== void 0 ? _h : undefined,
        });
    });
    return onlyOneRenderAtATimeQueue.ref;
};
