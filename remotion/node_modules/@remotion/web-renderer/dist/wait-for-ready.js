import { withResolvers } from './with-resolvers';
export const waitForReady = ({ timeoutInMilliseconds, scope, signal, apiName, internalState, }) => {
    const start = performance.now();
    const { promise, resolve, reject } = withResolvers();
    let cancelled = false;
    const check = () => {
        if (cancelled) {
            return;
        }
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            cancelled = true;
            internalState === null || internalState === void 0 ? void 0 : internalState.addWaitForReadyTime(performance.now() - start);
            reject(new Error(`${apiName}() was cancelled`));
            return;
        }
        if (scope.remotion_renderReady === true) {
            internalState === null || internalState === void 0 ? void 0 : internalState.addWaitForReadyTime(performance.now() - start);
            resolve();
            return;
        }
        if (scope.remotion_cancelledError !== undefined) {
            cancelled = true;
            internalState === null || internalState === void 0 ? void 0 : internalState.addWaitForReadyTime(performance.now() - start);
            reject(scope.remotion_cancelledError);
            return;
        }
        if (performance.now() - start > timeoutInMilliseconds + 3000) {
            cancelled = true;
            internalState === null || internalState === void 0 ? void 0 : internalState.addWaitForReadyTime(performance.now() - start);
            reject(new Error(Object.values(scope.remotion_delayRenderTimeouts)
                .map((d) => d.label)
                .join(', ')));
            return;
        }
        requestAnimationFrame(check);
    };
    requestAnimationFrame(check);
    return promise;
};
